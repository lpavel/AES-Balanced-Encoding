\documentclass[conference]{IEEEtran}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{url}
\usepackage{subfigure}
\usepackage{booktabs,threeparttable,multirow}

% new math operators
\DeclareMathOperator{\abs}{abs}

% todo command
\usepackage{marginnote}
\newcounter{todocnt}
\newcommand{\Sim}{\textsc{Simon}} 
\setcounter{todocnt}{0}
\newcommand{\todo}[1]{\stepcounter{todocnt}{\tt {[#1]}} \marginpar{{$\blacksquare$ \thetodocnt}}}  
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\hyphenation{op-tical net-works semi-conduc-tor}
\IEEEoverridecommandlockouts
\begin{document}

\title{Balanced Encoding of a Lightweight Cipher on an ARM Processor}


\author{\IEEEauthorblockN{Laurentiu Pavel
}
\IEEEauthorblockA{Worcester Polytechnic Institute, 
Worcester, MA 01609, USA\\
Email: \texttt{\{lpavel\}@wpi.edu}
}}
\maketitle

\begin{abstract}

  The Simon Cipher presented in ~\cite{Beaulieu_Simon} is a lightweight cipher created to better suit the embedded devices that are incrisingly being used in the society. Since physical access to a device offers the possibility of side channel attacks, the goal of this work is to privde an implementation of the Simon Cipher that is protected against them. The solution relies on achieving a constant leakage that cannot be used in order to discover the secret key.

\end{abstract}

\section{Motivation}

Once the internet takes over most of the devices people interact with, the concern of keeping information private becomes higher. Also small embedded devices need to have low costs and therefore do not have very high computational power. Thus small devices need ciphers that do not require very complex operations such as matrix multiplication in AES, and that also do not use very much memory.

Simon is one of the lightweight ciphers introduced by the NSA that could be used by many small devices in the future. Since it has been proven that Simon is vulnerable to Differential Power Analysis, the motivation of our work is to make an implementation of the cipher that is immune to Side Channel Attacks by achieving a constant leakage in all operations.

The development kit used is a Stellaris LM3S8962 that has an ARM Cortex M3 processor that runs at 50MHz. Because Side Channel Attacks are much easier to be done at a lower frequency, it was decided to use the board at a 5MHz clock rate. The motivation for choosing this platform was the popularity of ARM processors that are nowadays used in a very wide variety of products because of their very low power consumption.

List of goals:
\begin{itemize}
        \item achieve constant Hamming Weight and constant Hamming Distance between the states by different encodings.
        \item Perform side channel attacks on both implementations and check results.
\end{itemize}


We will stick to the following timeline (updated based on our project):

\begin{itemize}
	\item 2/22: Project goals and outline defined
	\item 3/1 : Related work identified and described in report.
	\item 3/15: Implement all the ciphers
	\item 3/22: Do the CPA and DPA
	\item 3/29: Process results
	\item 4/5:  Your results and outcomes are now also documented and included in the paper
	\item 4/12: Final submission of of complete paper for review
	\item 4/21: Reviews complete
	\item 4/26: Submission of final version addressing reviewers comments.
	\item 5/4 : Presentation of your project in class.
\end{itemize}

\section{Background}\label{sec:background}

\subsection{Side Channel Attacks}

In the second part of the 90's, it became obvious that hardware related cryptanalysis is very powerful and can break some mathematically strong ciphers by measuring hardware characteristics such as time, power consumption, temperature, etc. Kocher introduced the Timing Attack in 1996 ~\cite{KocherTiming} and then the more powerful Differential Power Analysis in 1999 ~\cite{KocherDPA} , reason why cryptography needed to be thought in such a way that physical access to a device does not allow Side Channel Attacks the possibility of discovering the key of the cipher. Another very powerful Side Channel Attack family is Cache Attacks introduced in \cite{Boneau} by Boneau et al. These attacks do not require entire physical access to the device, but it only needs to measure the time required for the computations. At the moment the field is very popular since there is no cipher that does not have any attack proven to work against it. 

\subsection{Countermeasures for Side Channel Attacks}

There are several approaches to protect agains SCA, most of them not trying to reduce the leakage, but making it unexploitable by randomizing it, some of the more popular ones being shuffling ~\cite{WangShuffling} , random delays ~\cite{CoronRandomDelays} , etc. Another interesting approach is presented in ~\cite{BEPrince} and ~\cite{ServantAES} where the aim is to obatin constant leakage during all the operations of the cipher which does not allow an attacker to gather same information when phyiscally attacking it which is not exploitable. The idea behind both of them is to use a bigger number of bits to represent the numbers in such a way that the Hamming Weight will always be constant and therefore not exploitable. Moreover, in ~\cite{BEPrince} it is presented an encoding of the Prince cipher that obatins constant leakage on the Hamming Distance Model as well. However, although this implementations reduce the leakage in models such as Hamming Distance or Hamming Weight, there are still other models such as Most Significant Bit that should still leak information.

The results of the constant leakage implementation served as a motivation for further investigation. It is obvious that an encoding that uses more bits will need to use much more memory that may not be available in most platforms. Ciphers such as AES consisting of large Sboxes and other complex operations such as matrix multiplications suffer big losses in terms of speed, but especially in terms of memory. Using an encoding that doubles the number of bytes would transform the AES Sbox from $16 \times 16 = 256$ 1-byte numbers ($=256$B), into a $32 \times 32 = 1024$ 2-byte numbers ($\approx2$KB) which is already more memory than most low-priced microcontrollers have. For instance, in the much smarter implementation of AES presented in ~\cite{ServantAES} , the speed loss has a factor of 4.2, but the memory loss has a factor of 8.57, which shows how challenging it is to obtain good performance on traditional ciphers.

In this paper we investigate whether constant leakage implementation on lightweight ciphers are feasable. We chose to implement Simon ~\cite{Beaulieu_Simon} which has very small memory requirements on a Stellaris LM3S8962. Since the board offers 256-KB Flash and 64-KB SRAM, memory will be sufficient for many different encodings. The goal is to implement 2 versions of Simon: Simon 64/128 (64-bit block size and 128-bit key size) and Simon 128/128 (128-bit block size and 128-bit key size) in 3 different ways: one unprotected implementation, one implementation that offers constant Hamming Weight leakage, and lastly one implementation that offers both constant Hamming Weight and constant Hamming Distance leagake. In the end we want to compare the leakages among the three implementations along with a comparrison of the memory and speed performance in each case.

\section{Work Description}

\subsection{Simon Cipher}

Simon Cipher ~\cite{Beaulieu_Simon} is a Feistel cipher consisting in the following operations: bitwise XOR, $\oplus$ ; bitwise AND, $\And$ ; left circular shift S by j bits, $S^j$ . Unlike AES, Simon does not contain complicated operations like S-box or Mix Columns reason why its operations are cheaper in both memory and run time. Because Simon has been designed to be a good candidate for different platforms that may have more or less resources and may need to be very secure or not that secure, multiple versions that operate on different block sizes and key sizes of the cipher have been introduced.

Obeying the Fiestel cipher design, for every round i, the plaintext is split into 2 words $x_{i}$ and $x_{i+1}$. The initial key is also expanded into T different keys that will be used for each of the round. As presented in \cite{Beaulieu_Simon} , the transformation of the blocks into a new round is done the following way:
$R_{i}(x_{i}, x_{i+1}) = (x_{i+1} \oplus f(x_{i}) \oplus k_{i}, x)$, where
$f(x) = S(x) \And S^{8}(x) \oplus S^{2}(x)$ and $k_{i}$ is the key used for the $i^{th}$ round. For decription, the transformation is done in the following way:
$R_{k}^{-1}(x_{i}, x_{i+1}) = (x_{i+1}, x \oplus f(x_{i+1}) \oplus k_{i})$
The key expansion mentioned earlier is done in the following way:

\small
\begin{equation}
  k_{i+m} =
  \left\{
  \begin{array}{ll}
    c \oplus (z_{j})_{i} \oplus k_{i} \oplus (I \oplus S^{-1})S^{-3}k_{i+1} & \mbox{, if } m = 2 \\
    c \oplus (z_{j})_{i} \oplus k_{i} \oplus (I \oplus S^{-1})S^{-3}k_{i+2} & \mbox{, if } m = 3 \\
    c \oplus (z_{j})_{i} \oplus k_{i} \oplus (I \oplus S^{-1})(S^{-3}k_{i+2} \oplus k_{i+1}) & \mbox{, if } m = 4 \\
  \end{array}
  \right.
\end{equation}
\normalsize

where $(z_{j})_{i}$ is a binary value of a matrix in which line j depends on the cipher used and i corresponds to the round.

\subsection{Balanced Encoding}

The regular binary encoding used by all machines leak information. The Hamming Weight (HW) is defined as the number of non-zero symbols in a representation ($HW(980802_{10}) = 4$ , $HW(1001101_{b}) = 4$). It is obvious that in the binary representation used by the hardware to store and compute, it is very likely that the two 64-bit numbers used for the operations will have different Hamming Weights which will leak information.

In 2011, Hoogvorst et al.  ~\cite{Hoogvorst} proposed in 2011 a Software Countermeasure to protect against Side Channel Attacks. The main idea is to map every bit such that it will always be represented by a 1 and a 0. For example 1 $\rightarrow$ 10 and 0 $\rightarrow$ 01. This representation assures constant Hamming Weight since all numbers will contain the same number of 0s and 1s. Also, if the hardware support zeroing the registers before every operation on them, this implementation would result into a constant Hamming Distance since the distance for writes on the register will always be equal to the Hamming Weight. Moreover, another advantage of this representation is that it can easily detect faults since it is obvious that no number should be represented as 2 0s or 2 1s. In the papers ~\cite{BEPrince} and ~\cite{ServantAES}, different type of encodings that maintain constant Hamming Weight have been used to better fit the cipher. The reason why we chose the regular encoding presented in the beginning of the paragraph is because Simon has a circular shift operation which not only that would be much harder to implement if all the bits are not kept together and in order, but in the simple version a rotation $S^{2j}$ would give the right result and also always transfer a value that has constant Hamming Weight.

The first implementation used in this study is Simon64/128. It consists in a block size of 64 bits, word size of 32 bits, and key size of 128 bits. In this implementation, the Feistel operations are being performed in 44 rounds. The second implementation used in this study is Simon128/128 which consists in a block size of 128 bits, word size of 64 bits, and key size of 128 bits.


It is important to be mentioned that this encoding does not offer constant Hamming Distance between terms and results. In ~\cite{BEPrince} , the authors managed to write the operations of the Prince Cipher such that they offer a constant Hamming Distance. In our case, in order to receive a constant Hamming Distance, the registers could be zeroed before operations are done to them.

The balanced encoding has been written in C. Since the microcontroller (and the C language) do not support word sizes bigger than 64 bits, let's define balanced word to be the word used in C for representing the numbers. As an example, in the regular implementations, the word size and the balanced word size are the same. The main idea behind our implementation is to keep the balanced word size the same as before while the word size will be doubled (it needs to be doubled because a Feistel cipher operates on 2 words) i.e. the Simon64/128 implementation will become a Simon128/256 which will still have a balanced word size of 32 bits; similarly Simon128/128 will become Simon256/256 which will have a balanced word size of 64 bits. In this representation, every variable was converted into an array of size 2 that each stores a half of each piece used.   

Storing the variables in the way presented above makes the operations AND and XOR easy to implement. It is enough to do the operations on the first half of the word from each piece and respectively on the second half of the word. For example, the XOR on two pieces piece1 and piece2 stored as arrays of size 2, $res[0] = piece1[0] \oplus piece2[0]$ and $res[1] = piece1[1] \oplus piece2[1]$ after which res contains the result of the operation in the proper encoding. The AND operation can be implemented similarly. The operations AND and XOR on balanced words have a straightforward implementation. We first split each balanced word into groups of 2 bits, and then take one form each balanced word in corresponding group. The first bit of the result is obtained by performing the operation on the first bit of the 2 groups. The second bit is obtained by taking the oposite of the first one.

For example, let's take $5 = 101_{b}$ and $6 = 110_{b}$ . $5 \And 6 = 4 = 100_{b}$. In balanced encoding: $5 = 100110_{b}$ and $6 = 101001_{b}$. Now split the two numbers into groups of 2 words and perform AND on corresponding groups. First group $10 \And 10$. Do AND on the first bit: $1 \And 1 = 1$ and take its oposite value 0. The the result of the operation will be 10. Doing the same thing for the next 2 groups, we obtain the result $100101_{b}$ which corresponds to 100 in a regular binary representation which is equal to 4 (the result we wanted). 

The left circular shift is the only operation of the three used by Simon in which the first half and the second half need to interact with each other. However, the representation used allows us to perform a circular left shift by 2j instead of j in the regular Simon. One straightforward implementation is applying the circular shift by 2j on each half of the word (the 2 balanced words that represent a piece of the Fiestel network). Then take swap the first 2j bits between the first half and the second half of the word to obtain the result in the proper encoding.

TODO:

- put it into the ARM microprocessor and look at the assembly

- make also a version that writes 0 on the registers. This should be done only in assembly

Here you describe the work you have performed, problems you have solved and methods you have used. There is a fine balance between brevity and conciseness and ensuring that other people, if investing the time, would be able to reproduce your results given this description.



\section{Results}
\todo{here you will present and discuss your outcomes: implementation results or measurements or other project outcomes}

\section{Conclusion}
\todo{TBD last}



%\bibliographystyle{IEEETR}
\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
